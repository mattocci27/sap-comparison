---
title: ""
author: "Masatoshi Katabuchi"
date: "`r format(Sys.time(), '%B %d, %Y')`"
fontsize: 12pt
format:
  html:
    theme: coderpro
    toc: true
    toc-depth: 2
    number-sections: true
    smooth-scroll: true
    standalone: true
    embed-resources: true
---

```{r global_options, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  cache = FALSE,
  fig.align = "center",
  fig.show = "hold"
)
```

```{r, echo=FALSE}
# renv::install("adletaw/captioner")
# renv::repair()
library(targets)
library(tidyverse)
```

```{r}
d <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(imp2_df))

d2 <- d |>
    filter(is.na(k_1st_imputed_with_na)) |>
    filter(!is.na(k_ori))

library(smatr)
fit <- sma(k_2nd_imputed ~ k_1st_imputed, d2)
summary(fit)
```


```{r}
# library(viridis)
# Create a vector with 70% 1s and 30% NAs
set.seed(1234)  # Setting seed for reproducibility
total_n <- 10
obs_n <- round(total_n * 0.7)
miss_n <- total_n - obs_n

ori_k <- sample(c(rep("K_original", obs_n), rep("Missing", miss_n)))
imp_k <- ori_k
imp_k[ori_k == "Missing"] <- "K_imputed"

re_k <- imp_k
re_k[sample(total_n, miss_n)] <- "Artificial Gap"

ori_k_df <- tibble(k = ori_k, data = "Original", id = 1:total_n)
imp_k_df <- tibble(k = imp_k, data = "1st Imputed", id = 1:total_n)
re_k_df <- tibble(k = re_k, data = "Artificial Gap", id = 1:total_n)

df <- bind_rows(ori_k_df, imp_k_df, re_k_df) |>
  mutate(k = factor(k, levels = c("K_original", "K_imputed", "Artificial Gap", "Missing")))

# Plot the data to resemble a barcode
ggplot(df, aes(y = id, x = data, fill = k)) +
  geom_tile(color = "white") +
  scale_fill_viridis_d(option = "D") +
  scale_y_continuous(breaks = 1:10) +
  theme_minimal() +
  theme(
    #axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        legend.text = element_text(size = 12),
        panel.grid = element_blank(),
        axis.title = element_blank()) +
  labs(fill = "Category")
```


![](`r paste0("file://", here::here("figs/imp_r2_comb.png"))`)

**Fig. SX: Validations of the imputed *K* values.**
**a** Observed vs. re-imputed *K*.
The density of overlapping points is reflected by a colour gradient ranging from blue (low point density) to yellow (high point density).
The dashed line represents the 1:1 line.
The solid blue line represents a linear regression.
The correlation is significant (*P* < 0.001).
The inset plot magnifies the lower range of *K* values because most of the values are concentrated in this range.
**b** An example of *K* value re-imputations for tree ID 11, measured at 2 cm depth from the south direction in February 2015.
Only the pairs of re-imputed values and the original non-missing values are shown.

```{r, echo=FALSE}
library(lubridate)
d <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(combined_imputed_k_mapped))

n_all <- nrow(d) |>
  format(big.mark = ",")

n_miss <- d |>
  filter(is.na(k_ori)) |>
  nrow() |>
  format(big.mark = ",")

n_r2 <- d |>
  filter(is.na(k_new_with_na)) |>
  filter(!is.na(k_ori)) |>
  nrow() |>
  format(big.mark = ",")
```


# Method for SI

To assess the accuracy of the imputation, we randomly removed values (*n* = `r n_miss`) from the imputed dataset to create a new dataset with additional missing values, excluding data from September, October, and December 2016 due to their excessive missing values.
This step was necessary because `missForest` does not store imputed values for non-missing entries; it only imputes missing data.
The missing values in this new dataset were then re-imputed.
Finally, we calculated the *R^2^* between the re-imputed values and the original non-missing values (*n* = `r n_r2`).

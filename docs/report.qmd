---
title: "Figures"
author: "Masatoshi Katabuchi"
date: "`r format(Sys.time(), '%B %d, %Y')`"
fontsize: 11pt
format:
  html:
    theme: spacelab #readable #sandstone #spacelab #flatly
    toc: true
    toc-depth: 2
    toc-title: Contents
    self-contained: true
    smooth-scroll: true
    highlight-style: github
---

```{r global_options, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  cache = FALSE,
  fig.align = "center",
  fig.show = "hold",
  root.dir = rprojroot::find_root('_targets.R')
)
```

```{r,include=FALSE}
library(tidyverse)
library(tarchetypes)
library(here)
library(kableExtra)
library(targets)
library(loo)
library(smatr)
library(GGally)
library(ggridges)
library(ggrepel)
source(here("R", "stan.R"))
source(here("R", "figs.R"))
anova_yml <- yaml::yaml.load_file(here("yml/anova.yml"))
```

**Note:
R codes are followed by tentative results.**

# Fig. 1

## Summary

- **Pressure > tension?**
Pressure induced flow rates tend to be greater than tension induced flow rates (positive $\mu$ = `ks_ratio`; the equation and the barplot for means).
Although it's not signifcant, the difference looks kinda clear from Fig. 1ab and the hierarchical model.

- **There are species effects.**
Species effects on the difference (ratio) between pressure and tension are relatively large (`r str_split(anova_yml$species, " ")[[1]][1]` of the total variance) but pressure-level effects are small (`r str_split(anova_yml$pressure, " ")[[1]][1]` of the total variance) .


## Visualization

(a): **Note that this standard major axis (SMA) regression is not that appropriate** because the data points include both interspecific and intraspecific variations, and thus residuals should not be independent.

Having said that, both elevation and slope shifted significantly (table below and Fig. 1a), suggesting that flow rates tend to be greater for pressure calibration.
Visualization itself is probably fine.
The thick line indicates SMA regression and shaded area indicates 95% confidence intervals.


(b): Each data point indicates each raw measurement (each tree has 3 measurements).
**This is just visualization but I think it's more useful and intuitive than just showing model estimates.**
**Analysis for this data is in the next section.**

It looks:

- Pressure > tension for HH and VM
- Pressure < tension for AP.

The effect of pressure-level is not clear.

We can check the patterns in more detail using hierarchical models below.


**Fig. 1.**
Flow rate under three levels of driving force employed as pressure or tension, normalized to maximum hydraulic conductivity (Ks) to account for small differences in sample lengths and diameter demonstrating the effect of increasing force on Ks (??).
(A) Relationship between sample mean pressure- and tension-induced flow rates.
Blue solid line indicates a standardized major axis (SMA) regression.
The 95% confidence interval is represented as the shaded area.
(B) Comparisons between pressure- and tension-induced flow rates at three levels for three diffuse-porous, one ring-porous, and one liana species.
The center line in each box indicates the median, and upper and lower box sides indicate the interquartile range.
The whiskers extend to a maximum of 1.5 times the interquartile range.
This is only to simplify the visualization, and statistical results are shown in SX.
HH, *Hopea hongayensis*;
VM, *Vatica mangachapoi*;
HB, *Hevea brasiliensis*;
TG, *Tectona grandis*;
AP, *Acacia pennata*.

![](`r here::here("figs/sma_ks.png")`)


```{r, include=FALSE}
# tar_load(ks_spp_err_csv)
ks_spp_err_csv <- withr::with_dir(rprojroot::find_root('_targets.R'), targets::tar_read(ks_spp_err_csv))
d <- read_csv(here(ks_spp_err_csv))
sma_fit <- sma(log10(tens_calib_mean) ~ log10(pres_calib_mean), d)
```

```{r}
sma_fit
```


## Analysis (ANOVA-like hierarchical model)

We can make the hierarchical model like the previous model, but we can include measurment errors from the raw data too.
We don't want to waste the data!

$$
y^{meas}_{1ijk} \sim N(y_{1ijk}, \sigma_{y1ijk})
$$

$$
y^{meas}_{2ijk} \sim N(y_{2ijk}, \sigma_{y2ijk})
$$

$$
\alpha_j \sim N(0, \sigma_{\alpha})
$$
$$
\beta_j \sim N(0, \sigma_{\beta})
$$

$$
\mathrm{ln}\; y_{1ijk} \sim N(\mu + \alpha_j + \beta_k + \mathrm{ln}\; y_{2ijk}, \sigma)
$$

- *i*: Obervation

- *j*: Species

- *k*: Pressure level

- $y^{meas}_{1ijk}$: Measured mean pressure induced flow rates for *i*th observation from *j*th species, under *k*th pressure level (data).
$y^{meas}_{2ijk}$ is for tension calibration.

- $y_{1ijk}$: True pressure induced flow rates for *i*th observation from *j*th species, under *k*th pressure level (parameter).
$y_{2ijk}$ is for tension calibration.

- $\sigma_{y1jk}$: Standard deviation of pressure induced flow rates for *i*th obervation from *j*th species, under *k*th pressure level (data).
This data can be estimated from the raw data with multiple measurements.
$\sigma_{y2jk}$ is for tension calibration.

- $\mu$: Overall (species and pressure-level independent) effects.

- $\alpha_j$: Species effect

- $\beta_k$: Pressure-level effect

- $\sigma_{\alpha}$: Standard deviation of the species effect

- $\sigma_{\beta}$: Standard deviation of the pressure-level effect

- $\sigma$: Standard deviation of the model (i.e., residuals)


I will show several figures from this single analysis.

### Variance

Posterior medians, 50%, and 95% credible intervals (CIs) for standard deviations estimated from the difference between pressure and tension induced flows.

![](`r here::here("figs/coef_intervals_sd.png")`){ width=350 }

Posterior medians, and 50% CIs for standard deviations estimated from the difference between pressure and tension induced flows.
The data to draw the figure is the same with the above, but you can clearly see the distribution of the true estimates.
Upper bounds of these estimates (especially pressure) tend to become very large due to the small group number (3-levels: 0.02, 0.05, and 0.08 MPa).
Using 50% CI instead of 95% CI might be OK but I'm not very sure.
Half of the shaded area (50% CI) should contain the true values.

![](`r here::here("figs/coef_density_sd.png")`){ width=350 }

We can translate the posterior distribution of standard deviations into an ANOVA like statement.

For example, we can calculate the species effect like:

$$
\frac{\sigma^2_{\alpha}}{\sigma^2_{\alpha} + \sigma^2_{\beta} + \sigma^2} \times 100\;(\%)
$$

**Species account for `r str_split(anova_yml$species, " ")[[1]][1]` of total variance for the ratio between pressure and tension induced flow rates, whereas pressure levels account for only `r str_split(anova_yml$pressure, " ")[[1]][1]` of the total variance.**
**Although pressure levels do not affect the differences in the two estimates, species effects are important.**
The effect of interactions was not selected after model selections.

- median and 50% CIs

- Species: `r anova_yml$species`

- Pressure: `r anova_yml$pressure`

- Residuals: `r anova_yml$residuals`

### Mean

Posterior medians, 50%, and 95% credible intervals (CIs) for species and pressure effects on the ratio between pressure and tension induced flows.
Positive values indicate pressure induced flow rates are greater than tension induced flow rates.

Pressure induced flow rates tend to be greater than tension induced flow rates (positive ks_ratio parameter).
This suggests a probability of getting larger values for pressure induced flow rates than for tension induced flow rates is about 90% (but less than 95%).
This is consistent with Fig. 1ab.

![](`r here::here("figs/coef_intervals_mean.png")`){ width=350 }

Here is a multiple comparison-like visualization.
The estimates for AP is smaller than HH, TG, and VM, suggesting that the difference between pressure and tension induced flow rates tends to be smaller for AP compared to HH, TG, and VM given that the overall effects is positive,
HB shows the similar pattern with AP.
This is also consistent with Fig. 1b.

![](`r here::here("figs/coef_intervals_diff.png")`){ width=350 }


# Fig. 2

## Check the raw data

```{r,eval=TRUE}
# tar_load(cond_count_csv)
cond_count_csv <- withr::with_dir(rprojroot::find_root('_targets.R'), targets::tar_read(cond_count_csv))

d <- read_csv(here(cond_count_csv))

ggplot(d, aes(x = as.factor(pressure), y = count/total * 100)) +
  geom_boxplot() +
  facet_wrap(~species)

ggplot(d, aes(x = pressure, y = count/total * 100)) +
  geom_point(aes(size = total), alpha = 0.6) +
#  scale_x_log10() +
#  geom_smooth(method = "lm") +
  facet_wrap(~species)
```

## For main text

We modeled the probability of a vessel filled with silicon as linear and quadratic logistic functions of perfusion pressures with varying- intercepts and slopes by species (Supporting information X).
Model selection using Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO; @Vehtari2014; @Vehtari2017) suggested that the quadratic model performed better (the difference in expected log pointwise predictive accuracies between the two models was 207.9), and thus we only report the result of the quadratic model.

**Legend:**
Changes in proportion of silicon-stained vessels along perfusion pressures.
Lines and shaded areas indicate the posterior medians and 95% credible intervals, respectively.
Size of data points (in blue) is proportional to the total number of vessels.

![](`r here::here("figs/count_pressure_quadratic.png")`){ width=200 }

## For supporting information

**Legend:**
Posterior medians, 50%, and 95% credible intervals (CIs) for model coefficients of the effects of perfusion pressure on the probability of a vessel filled with silicon.
All, Common effects across all the species;
HH, *Hopea hongayensis*;
VM, *Vatica mangachapoi*;
HB, *Hevea brasiliensis*;
TG, *Tectona grandis*;
AP, *Acacia pennata*.

![](`r here::here("figs/coef_intervals_logistic.png")`){ width=450 }

### Stan code

```{stan, file=here::here('stan/hierarchical_logistic.stan'), echo=TRUE, eval=FALSE, output.var="hoge"}
```

```{r,eval=FALSE}
# library(loo)
# tar_load(quad_logistic_mcmc_hierarchical_logistic)
# tar_load(simple_logistic_mcmc_hierarchical_logistic)
# loo(quad_logistic_mcmc_hierarchical_logistic)

# loo1 <- simple_logistic_mcmc_hierarchical_logistic$loo()
# loo2 <- quad_logistic_mcmc_hierarchical_logistic$loo()
# loo_compare(loo1, loo2)
```

# Coefficients a and b without traits

Multilevel model with cleaned data with full range of $\Delta$ P.

### Stan code

```{stan, file=here::here('stan/granier_without_traits.stan'), echo=TRUE, eval=FALSE, output.var="hoge2"}
```

```{r}
d <- read_csv(here("data/fd_k_traits.csv")) |>
  filter(is.na(removed_k))
```
```{r}
para <- read_csv(here("data/ab_var_clean_008.csv"))
```


## Variance partitioning

Figures are based on the multilevel model for the cleaned data without abnormal values with P~g~ <= 0.08 (i.e, all the range).

![](`r here::here("figs/coef_density2.png")`)


- Coefficient a (median [25% CI, 75% CI])

    - segments:
`r get_post_para(para, "var_a_segment", "q50")`%
[`r get_post_para(para, "var_a_segment", "q25")`,
`r get_post_para(para, "var_a_segment", "q50", digits = 1, nsmall = 1)`
].

    - species:
`r get_post_para(para, "var_a_sp", "q50")`%
[`r get_post_para(para, "var_a_sp", "q25")`,
`r get_post_para(para, "var_a_sp", "q50", digits = 1, nsmall = 1)`
].

    - xylem types:
`r get_post_para(para, "var_a_xylem", "q50")`%
[`r get_post_para(para, "var_a_xylem", "q25")`,
`r get_post_para(para, "var_a_xylem", "q50", digits = 1, nsmall = 1)`
].

- Coefficient b (median [25% CI, 75% CI])

    - segments:
`r get_post_para(para, "var_b_segment", "q50")`%
[`r get_post_para(para, "var_b_segment", "q25")`,
`r get_post_para(para, "var_b_segment", "q50", digits = 1, nsmall = 1)`
].

    - species:
`r get_post_para(para, "var_b_sp", "q50")`%
[`r get_post_para(para, "var_b_sp", "q25")`,
`r get_post_para(para, "var_b_sp", "q50", digits = 1, nsmall = 1)`
].

    - xylem types:
`r get_post_para(para, "var_b_xylem", "q50")`%
[`r get_post_para(para, "var_b_xylem", "q25")`,
`r get_post_para(para, "var_b_xylem", "q50", digits = 1, nsmall = 1)`
].


For coefficient a, xylem types are the largest source for the variance, while segments are the the largest source for the variance for coefficient b.

## Pool vs multilevel

![](`r here::here("figs/pool_multi.png")`)

## Coefficients (a and b) vs pressure gradients

Species $\times$ *P~g~* combinations with n < 5 are removed.
The upper limit for x-axis is based on the dataset.

![](`r here::here("figs/pg_ribbon_a.png")`)

![](`r here::here("figs/pg_ribbon_b.png")`)

## Fd vs K for different ranges of pressure gradients

![](`r here::here("figs/pg_multi.png")`)

## *A. catechu*

- The sample number 3 doesn't have high *Pg*
- The sample number 4 has small K

These make high *Pg* with low K and Fd as in the figure below, and resulted in greater coefficient *a* and *b* at the lower *Pg*.


```{r}
library(viridis)
d <- read_csv(here("data/fd_k_traits.csv"))
#  filter(is.na(removed_k))

cate <- d |>
  filter(sp_short == "A. catechu")

ggplot(cate, aes(x = k, y = fd, col = p_g)) +
  geom_point(size = 5) +
  scale_color_viridis()

ggplot(cate, aes(x = k, y = fd, col = p_g)) +
  geom_point(size = 3) +
  facet_wrap(~sample_number) +
  scale_color_viridis()

tmp2 <- cate |>
  filter(p_g <= 0.02) |>
  mutate(p_g_range = "<= 0.02")
tmp3 <- cate |>
  filter(p_g <= 0.03) |>
  mutate(p_g_range = "<= 0.03")
tmp4 <- cate |>
  filter(p_g <= 0.04) |>
  mutate(p_g_range = "<= 0.04")
tmp8 <- cate |>
  filter(p_g <= 0.08) |>
  mutate(p_g_range = "<= 0.08")

tmp <- bind_rows(tmp2, tmp3, tmp4)
```

```{r, fig.height = 2.5}
ggplot(tmp, aes(x = k, y = fd, col = p_g)) +
  facet_wrap(~ p_g_range) +
  geom_point(size = 3) +
  scale_color_viridis()
```

## *C. lutescens*

- The sample number 2 and 3 look weird.

- The sample number 5 has much greater K and Fd compared to the other samples, and the data point from sample number 5 with *Pg* <= 0.02 makes large coefficient *a* and *b* for *Pg* <= 0.02.

```{r}
lute <- d |>
  filter(sp_short == "C. lutescens")

ggplot(lute, aes(x = k, y = fd, col = p_g)) +
  geom_point(size = 5) +
  scale_color_viridis()

ggplot(lute, aes(x = k, y = fd, col = p_g)) +
  geom_point(size = 3) +
  facet_wrap(~sample_number) +
  scale_color_viridis()

tmp2 <- lute |>
  filter(p_g <= 0.02) |>
  mutate(p_g_range = "<= 0.02")
tmp3 <- lute |>
  filter(p_g <= 0.03) |>
  mutate(p_g_range = "<= 0.03")
tmp4 <- lute |>
  filter(p_g <= 0.04) |>
  mutate(p_g_range = "<= 0.04")
tmp8 <- lute |>
  filter(p_g <= 0.08) |>
  mutate(p_g_range = "<= 0.08")

tmp <- bind_rows(tmp2, tmp3, tmp4)
```

```{r, fig.height = 2.5}
ggplot(tmp, aes(x = k, y = fd, col = p_g)) +
  facet_wrap(~ p_g_range) +
  geom_point(size = 3) +
  scale_color_viridis()
```


# Coefficients a and b with traits

## Check traits

```{r}
d <- read_csv(here("data/fd_k_traits.csv"))
d <- d |>
  filter(!is.na(wood_density)) |>
  filter(!is.na(swc)) |>
  filter(!is.na(dh)) |>
  filter(!is.na(vaf)) |>
  filter(!is.na(vf)) |>
  filter(!is.na(ks))
d <- d |>
  filter(is.na(removed_k))

d |>
  filter(ks < 0.1)
```

```{r}
d2 <- d |>
  pivot_longer(c(wood_density, swc, dh, vaf, vf, ks, k))
```

```{r}
ggplot(d2, aes(x = value)) +
  geom_histogram() +
  facet_wrap(~name, scale = "free")
```

```{r}
ggplot(d2, aes(x = value)) +
  geom_histogram() +
  facet_wrap(~name, scale = "free") +
  scale_x_log10()
```

```{r}
tmp <- d |>
  group_by(sample_id) |>
  summarise_if(is.numeric, mean, na.rm = TRUE) |>
  mutate(
   log_swc = log(swc),
   log_dh = log(dh),
   log_vaf = log(vaf),
   log_vf = log(vf),
   log_ks = log(ks),
   log_k = log(k)) |>
  dplyr::select(wood_density, log_dh, log_vaf, log_vf, log_ks, log_k)

GGally::ggpairs(tmp)
```

I have already removed SWC from the analysis because SWC has the almost same information with wood density.
I added K in this figure just to see the relationship with other traits.


### Stan code

The model has 4 levels

- data level: log(Fd) = log(a) + b * log(Ks) + error

- segment level: a (or b) = alpha0 + alpha1 * trait1 + alpha2 * trait2 + ... + error, where alpha is species-level means

- species level: alpha has xylem level means beta

- xylem level: beta has across xylem level means gamma

gamma is


```{stan, file=here::here('stan/granier_with_traits.stan'), echo=TRUE, eval=FALSE, output.var="hoge3"}
```

Traits used in the model were:

- wood density

- log(dh)

- log(vaf)

- log(vf)

- log(ks)

I put all the traits in the model at the same time, and the model with wood density, log(dh), log(vaf) and log(ks) was the best model.
Only log(ks) had a significant effects on the coefficient *a* though.

```{r}

l1 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_all))
l2 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_vaf))
l3 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_vf))
l4 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_ks))
l5 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_noks))
l6 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_noks2))

loo_compare(l1, l2, l3, l4, l5, l6)
```

```{r}
s2 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_abt_summary_granier_with_traits_sap_trait_clean_vaf))
```

## a and b vs Ks

```{r}
d <- read_csv(here("data/fd_k_traits.csv")) |>
  filter(is.na(removed_k)) |>
  filter(!is.na(wood_density)) |>
  filter(!is.na(swc)) |>
  filter(!is.na(dh)) |>
  filter(!is.na(vaf)) |>
  filter(!is.na(vf)) |>
  filter(!is.na(ks))

ks_mean <- mean(log(d$ks))
ks_sd <- sd(log(d$ks))

rescale <- function(x) {
  ks_mean + x * ks_sd
}

d2 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_abt_draws_granier_with_traits_sap_trait_clean_vaf)) |>
  janitor::clean_names()

s2 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_abt_summary_granier_with_traits_sap_trait_clean_vaf)) |>
  janitor::clean_names()

stan_data <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(sap_trait_clean_vaf))

xx <- seq(min(stan_data$xj[, 5]), max(stan_data$xj[, 5]), length = 80)

a_est <- s2 |>
  filter(str_detect(variable, "A\\[1")) |>
  filter(!str_detect(variable, "_")) |>
  pull(q50) |>
  exp()
b_est <- s2 |>
  filter(str_detect(variable, "A\\[2")) |>
  filter(!str_detect(variable, "_")) |>
  pull(q50)

pred_points <- tibble(a_est, b_est, x = rescale(stan_data$xj[, 5]))

s2 |>
  filter(str_detect(variable, "alpha_a\\[4")) |>
  head(20)

pred_nd <- d2 |>
  dplyr::select(
    a_int = gamma_a_1_1,
    a_slope = gamma_a_5_1,
    b_int = gamma_b_1_1,
    b_slope = gamma_b_5_1) |>
  mutate(.id = 1:nrow(d2)) |>
  mutate(pred_a = map2(a_slope, a_int, \(slope, int) int + slope * xx)) |>
  mutate(pred_b = map2(b_slope, b_int, \(slope, int) int + slope * xx)) |>
  mutate(.iter = map(.id, \(x)1:80))

pred_a <- pred_nd |>
  dplyr::select(.id, .iter, pred_a) |>
  unnest(cols = c(pred_a, .iter)) |>
  pivot_longer(pred_a) |>
  group_by(.iter) |>
  summarize(
    ll = quantile(value, 0.025) |> exp(),
    l = quantile(value, 0.25) |> exp(),
    m = quantile(value, 0.5) |> exp(),
    h = quantile(value, 0.75) |> exp(),
    hh = quantile(value, 0.975) |> exp()
  ) |>
  mutate(xx = rescale(xx))

pred_b <- pred_nd |>
  dplyr::select(.id, .iter, pred_b) |>
  unnest(cols = c(pred_b, .iter)) |>
  pivot_longer(pred_b) |>
  group_by(.iter) |>
  summarize(
    ll = quantile(value, 0.025) |> exp(),
    l = quantile(value, 0.25) |> exp(),
    m = quantile(value, 0.5) |> exp(),
    h = quantile(value, 0.75) |> exp(),
    hh = quantile(value, 0.975) |> exp()
  ) |>
  mutate(xx = rescale(xx))

ggplot(pred_a) +
  geom_point(data = pred_points, aes(x = x, y = a_est)) +
  geom_line(aes(x = xx, y = m)) +
  geom_ribbon(aes(x = xx, ymin = l, ymax = h), alpha = 0.4) +
  geom_ribbon(aes(x = xx, ymin = ll, ymax = hh), alpha = 0.4) +
  scale_y_log10() +
  my_theme() +
  ylab(expression(Coefficient~italic(a))) +
  xlab(expression(italic(K)[s]~(kg~m^{-1}~s^{-1}~MPa^{-1})))

ggplot(pred_b) +
  geom_point(data = pred_points, aes(x = x, y = b_est)) +
  geom_line(aes(x = xx, y = m)) +
  geom_ribbon(aes(x = xx, ymin = l, ymax = h), alpha = 0.4) +
  geom_ribbon(aes(x = xx, ymin = ll, ymax = hh), alpha = 0.4) +
  my_theme() +
  ylab(expression(Coefficient~italic(b))) +
  xlab(expression(italic(K)[s]~(kg~m^{-1}~s^{-1}~MPa^{-1})))
```


The predicted lines are based on gamma values in the model.

log(vaf) has a week effect on *b*.
I will check this.

```{r}
knitr::knit_exit()
```

## all species

```{r}
s_0015 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits_sap_all_clean_0.015)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.015")

data <- s_0015    |>
  filter(str_detect(variable, "alpha\\[1"))

data$variable

s_002 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits_sap_all_raw_0.02)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.02")
s_003 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits_sap_all_raw_0.03)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.03")
s_004 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits_sap_all_raw_0.04)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.04")
s_005 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits_sap_all_raw_0.05)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.05")
s_006 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits_sap_all_raw_0.06)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.06")
s_007 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits_sap_all_raw_0.07)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.07")
s_008 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits_sap_all_raw_0.08)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.08")


a_data <- bind_rows(s_003, s_004, s_005, s_006, s_007, s_008) |>
  filter(str_detect(variable, "alpha\\[1"))

ggplot(a_data, aes(x = pressure, y = q50, group = variable)) +
  geom_point() +
  geom_line() +
  ylab("log(a)")

b_data <- bind_rows(s_003, s_004, s_005, s_006, s_007, s_008) |>
  filter(str_detect(variable, "alpha\\[2"))

ggplot(b_data, aes(x = pressure, y = q50, group = variable)) +
  geom_point() +
  geom_line() +
  ylab("b")

```

## Rubber (*Hevea brasiliensis*) only

**This is not a regression.**
I just connected each pressure gradient.
The line and dots are posterior medians.
The dark shaded region is 50% Bayesian CI.
The light shaded region is 95% Bayesian CI.
There seems to be different between <0.03 and <0.04 but I cannot say if it is statistically significant.


```{r}
a_rubber <- a_data |>
  filter(variable == "alpha[1,7]")

ggplot(a_rubber, aes(x = pressure, y = exp(q50), group = variable)) +
  geom_point() +
  geom_line() +
  geom_ribbon(aes(ymin = exp(q2_5), ymax = exp(q97_5)), alpha = 0.4) +
  geom_ribbon(aes(ymin = exp(q25), ymax = exp(q75)), alpha = 0.4) +
  ylab("Coefficient a") +
  xlab(expression(italic(P[g])~(MPa~m^{-1})))

```

```{r}
b_rubber <- b_data |>
  filter(variable == "alpha[2,7]")

ggplot(b_rubber, aes(x = pressure, y = q50, group = variable)) +
  geom_point() +
  geom_line() +
  geom_ribbon(aes(ymin = q2_5, ymax = q97_5), alpha = 0.4) +
  geom_ribbon(aes(ymin = q25, ymax = q75), alpha = 0.4) +
  ylab("Coefficient b") +
  xlab(expression(italic(P[g])~(MPa~m^{-1})))

```


## All species

```{r, fig.width=10, fig.height=10}

sp_lab <- d |>
  dplyr::select(sp = species, xylem_type) |>
  unique() |>
  mutate(sp_fct = as.factor(sp)) |>
  mutate(sp_num = as.numeric(sp_fct)) |>
  mutate(sp_num1 = str_c("1_", sp_num))  |>
  mutate(sp_num2 = str_c("2_", sp_num))  |>
  arrange(sp_num1)

xy_lab <- d |>
  dplyr::select(xylem_type, species, sp_short) |>
  unique() |>
  mutate(xylem_fct = as.factor(xylem_type)) |>
  arrange(xylem_fct) |>
  mutate(xylem_long = case_when(
    xylem_type == "DP"  ~ "Diffuse-porous tree",
    xylem_type == "RP"  ~ "Ring-porous tree",
    xylem_type == "Pa"  ~ "Palm",
    xylem_type == "L"  ~ "Liana"
  )) |>
  mutate(xylem_long_fct = factor(xylem_long,
  levels = c("Diffuse-porous tree", "Ring-porous tree", "Palm", "Liana"))) |>
  mutate(sp_fct = as.factor(species)) |>
  mutate(sp_num = as.numeric(sp_fct)) |>
  mutate(sp_num1 = str_c("1_", sp_num))  |>
  mutate(sp_num2 = str_c("2_", sp_num))  |>
  arrange(species)


xy_lab |>
  mutate(variable = str_c("alpha[1,", sp_num,"]")) |>
  dplyr::select(sp_short, variable, xylem_long_fct) |>
  full_join(a_data) |>
  ggplot(aes(x = pressure, y = exp(q50), group = sp_short, fill = xylem_long_fct)) +
  facet_wrap(~sp_short, ncol = 4, scale = "free") +
  geom_ribbon(aes(ymin = exp(q2_5), ymax = exp(q97_5)), alpha = 0.4) +
  geom_ribbon(aes(ymin = exp(q25), ymax = exp(q75)), alpha = 0.6) +
  geom_point() +
  geom_line() +
  scale_fill_discrete(name = "") +
  scale_y_log10() +
  ylab(expression(Coefficient~italic(a))) +
  xlab(expression(Maximum~italic(P[g])~(MPa~m^{-1}))) +
  my_theme() +
  theme(
    strip.text = element_text(face = "italic", size = 8),
    legend.position = c(0.85, 0.05)
    )

xy_lab |>
  mutate(variable = str_c("alpha[2,", sp_num,"]")) |>
  dplyr::select(sp_short, variable, xylem_long_fct) |>
  full_join(b_data) |>
  ggplot(aes(x = pressure, y = q50, group = sp_short, fill = xylem_long_fct)) +
  facet_wrap(~sp_short, ncol = 4, scale = "free") +
  geom_ribbon(aes(ymin = q2_5, ymax = q97_5), alpha = 0.4) +
  geom_ribbon(aes(ymin = q25, ymax = q75), alpha = 0.6) +
  geom_point() +
  geom_line() +
  scale_fill_discrete(name = "") +
  ylab(expression(Coefficient~italic(b))) +
  xlab(expression(Maximum~italic(P[g])~(MPa~m^{-1}))) +
  my_theme() +
  theme(
    strip.text = element_text(face = "italic", size = 8),
    legend.position = c(0.85, 0.05)
    )

```


```{r,eval=FALSE}
d |>
  filter(species == "Areca catechu") |>
  ggplot(aes(x = k, y = fd, col = sample_id, fill = sample_id)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

```{r,eval=FALSE}
d |>
  filter(species == "Areca catechu") |>
  filter(p_g <= 0.03) |>
  ggplot(aes(x = k, y = fd, col = sample_id, fill = sample_id)) +
  geom_point() +
  geom_smooth(se = FALSE)
```


```{r,eval=FALSE}
d |>
  filter(species == "Parashorea chinensis") |>
  ggplot(aes(x = k, y = fd, col = sample_id, fill = sample_id)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

```{r,eval=FALSE}
d |>
  filter(species == "Parashorea chinensis") |>
  filter(p_g <= 0.03) |>
  ggplot(aes(x = k, y = fd, col = sample_id, fill = sample_id)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

```{r,eval=FALSE}
s2_008 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_summary_granier_without_traits2_sap_all_raw_0.08)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.08")

s_008 |>
  filter(str_detect(variable, "Omega"))

tmp2 <- s2_008 |>
  filter(str_detect(variable, "alpha\\[1")) |>
  mutate(model = "pool")
tmp <- s_008 |>
  filter(str_detect(variable, "alpha\\[1")) |>
  mutate(model = "multilevel")

tmp3 <- bind_rows(tmp, tmp2)
tmp4 <- sp_lab |>
  mutate(variable = str_c("alpha[1,",sp_num,"]")) |>
  dplyr::select(sp_fct, variable, xylem_type) |>
  full_join(tmp3)

tmp4 |>
  dplyr::select(sp_fct, xylem_type, q50, model) |>
  pivot_wider(names_from = model, values_from = q50) |>
  ggplot(aes(x = exp(pool), y = exp(multilevel))) +
  geom_point() +
  geom_text_repel(aes(label = sp_fct)) +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(intercept = 0, slope = 1)

```

```{r,eval=TRUE}
s3_008 <- withr::with_dir(rprojroot::find_root('_targets.R'),
  targets::tar_read(fit_ab_each_sap_sp_raw_0.08)) |>
  janitor::clean_names() |>
  mutate(pressure = "0.08")

log_a_multi <- s_008 |>
  filter(str_detect(variable, "alpha\\[1")) |> pull(q50)
log_a_pool <- s2_008 |>
  filter(str_detect(variable, "alpha\\[1")) |> pull(q50)

b_multi <- s_008 |>
  filter(str_detect(variable, "alpha\\[2")) |> pull(q50)
b_pool <- s2_008 |>
  filter(str_detect(variable, "alpha\\[2")) |> pull(q50)

get_log_a <- \(x) filter(x$summary, variable =="log_a") |> pull(q50)
get_b <- \(x) filter(x$summary, variable =="b") |> pull(q50)

fig_dat <- s3_008 |>
   ungroup() |>
   mutate(log_a_multi_each = map_dbl(fit2, get_log_a)) |>
   mutate(log_a_pool_each = map_dbl(fit, get_log_a)) |>
   mutate(b_multi_each = map_dbl(fit2, get_b)) |>
   mutate(b_pool_each = map_dbl(fit, get_b)) |>
   mutate(log_a_multi = log_a_multi) |>
   mutate(log_a_pool = log_a_pool) |>
   mutate(b_multi = b_multi) |>
   mutate(b_pool = b_pool) |>
   dplyr::select(-data, -stan_data, -fit, -fit2) |>
   full_join(sp_lab, c("species" = "sp"))

ggplot(fig_dat, aes(x = exp(log_a_multi), y = exp(log_a_multi_each))) +
  geom_point(aes(col = xylem_type)) +
  geom_text_repel(aes(label = sp_fct)) +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(intercept = 0, slope = 1)

ggplot(fig_dat, aes(x = exp(log_a_multi), y = exp(log_a_pool))) +
  geom_point(aes(col = xylem_type)) +
  geom_text_repel(aes(label = sp_fct)) +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(intercept = 0, slope = 1)

ggplot(fig_dat, aes(x = exp(log_a_multi_each), y = exp(log_a_pool_each))) +
  geom_point(aes(col = xylem_type)) +
  geom_text_repel(aes(label = sp_fct)) +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(intercept = 0, slope = 1)

ggplot(fig_dat, aes(x = exp(b_multi), y = exp(b_pool))) +
  geom_point(aes(col = xylem_type)) +
  geom_text_repel(aes(label = sp_fct)) +
  scale_x_log10() +
  scale_y_log10() +
  geom_abline(intercept = 0, slope = 1)
```

```{r}

nd$data[[1]]

log_a <- s_008 |>
  filter(str_detect(variable, "alpha\\[1")) |>
  pull(q50)
b <- s_008 |>
  filter(str_detect(variable, "alpha\\[2")) |>
  pull(q50)
sig <- s_008 |>
  filter(variable == "sigma") |>
  pull(q50)

log_a_pool <- s2_008 |>
  filter(str_detect(variable, "alpha\\[1")) |>
  pull(q50)
b_pool <- s2_008 |>
  filter(str_detect(variable, "alpha\\[2")) |>
  pull(q50)
sig_pool <- s2_008 |>
  filter(variable == "sigma") |>
  pull(q50)

nd <- d |>
  group_by(species, xylem_type) |>
  nest() |>
  ungroup() |>
  arrange(species) |>
  mutate(log_xx = map(data, \(x)seq(min(log(x$k)), max(log(x$k)), length = 80))) |>
  mutate(log_a = log_a) |>
  mutate(b = b) |>
  mutate(sig = sig) |>
  mutate(log_a_pool = log_a_pool) |>
  mutate(b_pool = b_pool) |>
  mutate(sig_pool = sig_pool) |>
  mutate(log_pred = pmap(list(log_xx, log_a, b, sig), \(log_xx, log_a, b, sig) log_a + b * log_xx + sig^2 / 2)) |>
  mutate(log_pred_pool = pmap(list(log_xx, log_a_pool, b_pool, sig_pool), \(log_xx, log_a, b, sig) log_a + b * log_xx + sig^2 / 2))

pred_data <- nd |>
  dplyr::select(xylem_type, species, log_xx, log_pred, log_pred_pool) |>
  unnest(c(log_xx, log_pred, log_pred_pool))

d_dp <- d |>
  filter(xylem_type == "Pa")
pred_dp <- pred_data |>
  filter(xylem_type == "Pa")

d |>
  ggplot() +
  geom_point(aes(x = k, y = fd, col = xylem_type)) +
  geom_line(data = pred_data, aes(x = exp(log_xx), y = exp(log_pred))) +
  geom_line(data = pred_data, aes(x = exp(log_xx), y = exp(log_pred_pool)), lty = 2) +
  facet_wrap(~ species, ncol = 4, scale = "free") +
    ylab(expression("Sap flux density "(g~m^{-2}~s^{-1}))) +
    xlab(expression("K "((Delta~T[max]-Delta~T)/Delta~T)))

```

```{r}
plot(k ~ ks ,d)
```

```{r, eval=FALSE}
tar_load(fit_ab_each_sap_sp_raw_0.08)
tar_load(sap_all_clean_0.08)

sap_all_clean_0.08 |> str()

sap_all_clean_0.08$ul
sap_all_clean_0.08$uk[1:4, 1:31]
sap_all_clean_0.08$uj[1:5,1:5]

m1 <- matrix(1:6, nrow = 2)
m2 <- matrix(c(1,1,1,0,1, 0,0,0,1), nrow = 3)
m1
m2
m1 %*% m2


hoge <- s_008 |>
  filter(str_detect(variable, "alpha\\[1")) |> pull(q50)

hoge2 <- s2_008 |>
  filter(str_detect(variable, "alpha\\[1")) |> pull(q50)

s_008 |>
   filter(variable == "alpha[1,1]")
  #filter(str_detect(variable, "alpha\\[2"))

s2_008 |>
  filter(variable == "alpha[1,1]")

s3_008 <- fit_ab_each_sap_sp_raw_0.08 |>
  arrange(species)

s3_008$fit[[4]]$summary |>
  filter(variable == "log_a")

s3_008 |>
   ungroup() |>
   mutate(log_a_pool2 = map_dbl(fit, \(x)(filter(x$summary, variable =="log_a") |> pull(q50)))) |>
   mutate(log_a_multi2 = map_dbl(fit2, \(x)(filter(x$summary, variable =="log_a") |> pull(q50)))) |>
   mutate(log_a_multi = hoge) |>
   mutate(log_a_pool = hoge2) |>

s3_008$fit2[[4]]$summary |>
  filter(variable == "log_a")

tmp <- d |>
  group_by(sample_id) |>
  summarise_if(is.numeric, mean, na.rm = TRUE) |>
  mutate(
   log_swc = log(swc),
   log_dh = log(dh),
   log_vaf = log(vaf),
   log_vf = log(vf),
   log_ks = log(ks)) |>
  dplyr::select(wood_density, log_dh, log_vaf, log_ks)

GGally::ggpairs(tmp)

m <- apply(tmp, 2, scale)
str(m)

m <- as.matrix(tmp)
pca <- prcomp(m, scale=TRUE)

hist(tmp$wood)

fit_ab_each2_sap_sp_raw_0.08$fit[[4]]$summary

log_xx <- seq(0.01, 0.8, length = 80)
log_yy <- log(119) * log_xx + 1.23
plot(exp(xx), exp(yy))

tibble(sp = letters[1:26]) |>
  group_by(sp) |>
  nest() |>
  ungroup() |>
  mutate(xx = list(exp(log_xx))) |>
  mutate(yy = list(exp(log_yy))) |>
  unnest(cols = c(data, xx, yy)) |>
  ggplot(aes(x = xx, y = yy)) +
  geom_line() +
  facet_wrap(~sp)



samp_data_a <- draws |>
  dplyr::select(starts_with("A_1")) |>
  pivot_longer(1:188)  |>
  arrange(name)
ggplot(samp_data_a, aes(x = exp(value), y = name))  +
 geom_density_ridges() +
 scale_x_log10() +
 xlab("Coefficient a")

sap_stan_data_each |>
  mutate(fit = map(stan_data, fit_model, granier_simple_file))

tar_load(fit_ab_each)

fit_ab_each$fit[[1]]$summary

tar_load(test_0.03)
tar_load(test_0.04)

str(test_0.03)
str(test_0.04)

tar_load(sap_stan_data_sp_all_0.04)
tar_load(sap_sp_clean_0.03)

tar_load(sap_sp_clean_0.03)
sap_sp_clean_0.03

tar_load(fit_ab_sap_sp_clean_0.03)
fit_ab2_sap_sp_clean_0.03$fit[[1]]$summary
fit_ab2_sap_sp_clean_0.08$fit[[1]]$summary

nd <- d |>
  group_by(species, sample_id) |>
  nest()

hoge <- tar_manifest()

hoge |>
  filter(str_detect(name, "sap_")) |>
  filter(str_detect(name, "sp"))

s1 <- tar_read(fit_abt_summary_granier_with_traits_sap_trait_clean_all)
s2 <- tar_read(fit_abt_summary_granier_with_traits_sap_trait_clean_vaf)
s3 <- tar_read(fit_abt_summary_granier_with_traits_sap_trait_clean_vf)
s4 <- tar_read(fit_abt_summary_granier_with_traits_sap_trait_clean_ks)


s4 |>
  filter(str_detect(variable, "alpha_a"))

my_a <- s4 |>
  filter(str_detect(variable, "A_hat\\[1"))
my_b <- s4 |>
  filter(str_detect(variable, "A_hat\\[2"))

s4 |>
  filter(str_detect(variable, "A_hat\\[1"))

my_a <- s4 |>
  filter(str_detect(variable, "A\\[1")) |>
  filter(!str_detect(variable, "_"))
my_b <- s4 |>
  filter(str_detect(variable, "A\\[2")) |>
  filter(!str_detect(variable, "_"))


plot(ks_s, my_a$q50)
plot(ks_s, my_b$q50)

tmp <- tar_read(sap_trait_clean_ks)
ks_s <- tmp$xj[,2]

s4 |>
  filter(str_detect(variable, "alpha_b"))

plot(k ~ ks, log = "xy", d)

m1 <- tar_read(fit_abt_mcmc_granier_with_traits_sap_trait_clean_all)
m2 <- tar_read(fit_abt_mcmc_granier_with_traits_sap_trait_clean_vaf)
m3 <- tar_read(fit_abt_mcmc_granier_with_traits_sap_trait_clean_vf)

d4 <- tar_read(fit_abt_draws_granier_with_traits_sap_trait_clean_ks) |>
  janitor::clean_names()

l1 <- tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_all)
l2 <- tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_vaf)
l3 <- tar_read(traits_loo_fit_abt_mcmc_granier_with_traits_sap_trait_clean_vf)
loo_compare(l1, l2, l3)

m1$loo

hoge |>
  filter(str_detect(name, "traits_loo"))


library(tictoc)
   tic()
    lapply(
      list(m1, m2, m3
        ),
    \(x)x$loo(cores = parallel::detectCores()))
    toc()

   tic()
    lapply(
      list(m1, m2, m3
        ),
    \(x)x$loo(cores = 1))
    toc()


tar_read(fit_ab_summary_granier_without_traits_sap_all_0.08)

c(4, 2) %*% t(c(1, 1, 1, 1))

library(targets)
hoge <- tar_manifest()

hoge |>
  filter(str_detect(name, "trait_clean"))

hoge <- tar_read(fit_abt_summary_granier_with_traits)

hoge |>
  filter(str_detect(variable, "A_hat"))

hoge |>
  filter(str_detect(variable, "L_Omega_j_a"))

hoge |>
  filter(str_detect(variable, "^A\\["))

hoge |>
#  filter(!str_detect(variable, "zj_A")) |>
  arrange(-rhat)

tar_read(sap_traits_clean_0.08) |> str()


s6 <- tar_read(fit_abt_summary_granier_with_traits_sap_trait_clean_noks2)

```



```{r, eval=FALSE}
targets::tar_visnetwork()
```


```{r, eval=FALSE}
devtools::session_info()
```
